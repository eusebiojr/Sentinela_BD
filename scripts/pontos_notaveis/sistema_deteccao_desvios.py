#!/usr/bin/env python3
"""
Sistema de Detec√ß√£o de Desvios de SLA - Monitoramento de Ve√≠culos em POIs
Baseado no Sistema Sentinela BD

Transforma o script de relat√≥rio em um sistema de alertas com n√≠veis N1-N4
para monitoramento hor√°rio de desvios de SLA por grupo de POIs.
"""

import json
import base64
import urllib.request
import urllib.parse
from datetime import datetime, timezone, timedelta
from collections import defaultdict, Counter
from zoneinfo import ZoneInfo
import csv

# Configura√ß√µes
CAMPO_GRANDE_TZ = ZoneInfo("America/Campo_Grande")

# Mapeamento POI ‚Üí Grupo (TAREFA 1) - APENAS grupos com SLA definido
MAPEAMENTO_POI_GRUPO = {
    # TLS - apenas grupos com SLA (F√°brica, Terminal, Ponto Apoio, Manuten√ß√£o)
    "Oficina Central JSL": "Manuten√ß√£o",
    "Carregamento Fabrica": "F√°brica", 
    "FILA DESCARGA APT": "Terminal",
    "Descarga TAP": "Terminal",
    "PA Celulose": "Ponto Apoio",
    "CEMAVI": "Manuten√ß√£o",
    "JDIESEL": "Manuten√ß√£o",
    "MONTANINI": "Manuten√ß√£o",
    "PB Lopes": "Manuten√ß√£o",
    "PB LOPES SCANIA": "Manuten√ß√£o",
    "MS3 LAVA JATO": "Manuten√ß√£o",
    "ADEVAR": "Manuten√ß√£o",
    "REBUCCI": "Manuten√ß√£o",
    "FEISCAR": "Manuten√ß√£o",
    "LM RADIADORES": "Manuten√ß√£o",
    "ALBINO": "Manuten√ß√£o",
    "DIESELTRONIC": "Manuten√ß√£o",
    "Manutencao Celulose": "Manuten√ß√£o",
    
    # RRP - apenas grupos com SLA
    "Descarga Inocencia": "Terminal",
    "Carregamento Fabrica RRP": "F√°brica",
    "Manutencao JSL RRP": "Manuten√ß√£o",
    "Oficina JSL": "Manuten√ß√£o", 
    "Manuten¬ø¬øo Geral JSL RRP": "Manuten√ß√£o",  # POI com caracteres especiais
    "PA AGUA CLARA": "Ponto Apoio"
    
    # IGNORADOS (sem SLA definido):
    # TLS: "POSTO DE ABASTECIMENTO", "Fila abastecimento posto", "SELVIRIA", "AREA EXTERNA SUZANO"
    # RRP: "Agua Clara", "Abastecimento Frotas RRP", "Posto Mutum", "Buffer Frotas"
}

# SLA por Filial e Grupo - CONFIGURA√á√ïES ATUALIZADAS
SLA_LIMITES = {
    "RRP": {
        "F√°brica": 6,      # Atualizado: 6 ve√≠culos
        "Terminal": 12,    # Atualizado: 12 ve√≠culos  
        "Manuten√ß√£o": 12,  # Atualizado: 12 ve√≠culos
        "Ponto Apoio": 6   # Atualizado: 6 ve√≠culos
    },
    "TLS": {
        "F√°brica": 5,      # Atualizado: 5 ve√≠culos
        "Terminal": 5,     # Atualizado: 5 ve√≠culos (APT)
        "Manuten√ß√£o": 10,  # Atualizado: 10 ve√≠culos
        "Ponto Apoio": 5   # Atualizado: 5 ve√≠culos
    }
}

# POIs por filial (do script original)
POIS_RRP = {
    "Manutencao JSL RRP", "Carregamento Fabrica RRP", "Buffer Frotas", 
    "Abastecimento Frotas RRP", "Oficina JSL", "Posto Mutum", "Agua Clara", 
    "PA AGUA CLARA", "Descarga Inocencia", "Manuten¬ø¬øo Geral JSL RRP"
}

POIS_TLS = {
    "Carregamento Fabrica", "AREA EXTERNA SUZANO", "POSTO DE ABASTECIMENTO", 
    "Fila abastecimento posto", "PA Celulose", "Manutencao Celulose", 
    "MONTANINI", "SELVIRIA", "FILA DESCARGA APT", "Descarga TAP", 
    "Oficina Central JSL", "PB Lopes", "PB LOPES SCANIA", "MS3 LAVA JATO", 
    "REBUCCI", "CEMAVI", "FEISCAR", "DIESELTRONIC", "LM RADIADORES", 
    "ALBINO", "JDIESEL", "ADEVAR"
}

POIS_FILTRADOS = POIS_RRP | POIS_TLS

def get_token():
    """Obt√©m token OAuth2"""
    client_id = "56963"
    client_secret = "1MSiBaH879w="
    oauth_url = "https://openid-provider.crearecloud.com.br/auth/v1/token?lang=pt-BR"
    
    credentials = f"{client_id}:{client_secret}"
    encoded_credentials = base64.b64encode(credentials.encode()).decode()
    
    headers = {
        'Authorization': f'Basic {encoded_credentials}',
        'Content-Type': 'application/json'
    }
    
    try:
        data = json.dumps({"grant_type": "client_credentials"}).encode('utf-8')
        request = urllib.request.Request(oauth_url, data=data, headers=headers, method='POST')
        
        with urllib.request.urlopen(request) as response:
            token_data = json.loads(response.read().decode('utf-8'))
            return token_data.get('id_token')
    except Exception as e:
        print(f"‚ùå Erro ao obter token: {e}")
        return None

def obter_filial_poi(poi_name):
    """Determina a filial baseada no POI"""
    if poi_name in POIS_RRP:
        return "RRP"
    elif poi_name in POIS_TLS:
        return "TLS"
    return "DESCONHECIDA"

def obter_grupo_poi(poi_name):
    """Obt√©m grupo do POI usando mapeamento"""
    # Tratamento especial para POI com caracteres quebrados
    if "Geral JSL RRP" in poi_name and "Manuten" in poi_name:
        return "Manuten√ß√£o"
    
    return MAPEAMENTO_POI_GRUPO.get(poi_name, "N√£o Mapeado")

def buscar_veiculos_ativos():
    """Busca ve√≠culos atualmente nos POIs com estrat√©gia de janelas adaptativa"""
    print("üîç Buscando ve√≠culos ativos com estrat√©gia adaptativa...")
    
    token = get_token()
    if not token:
        print("‚ùå Falha ao obter token")
        return []
    
    headers = {
        'Authorization': f'Bearer {token}',
        'Accept': 'application/json'
    }
    
    endpoint = "https://api.crearecloud.com.br/frotalog/specialized-services/v3/pontos-notaveis/by-updated"
    
    # Estrat√©gia adaptativa: come√ßar com janela pequena e expandir se necess√°rio
    agora_local = datetime.now(CAMPO_GRANDE_TZ)
    agora_utc = agora_local.astimezone(timezone.utc)
    
    # Definir janelas por tipo de opera√ß√£o
    janelas_grupo = {
        "Terminal": 24,      # 24 horas - opera√ß√µes de carga/descarga
        "F√°brica": 24,       # 24 horas - opera√ß√µes de carregamento  
        "Ponto Apoio": 24,   # 24 horas - paradas de apoio
        "Manuten√ß√£o": 72     # 3 dias (72h) - manuten√ß√µes longas
    }
    
    print(f"üìÖ Janelas temporais por grupo:")
    for grupo, horas in janelas_grupo.items():
        dias = horas / 24
        print(f"   ‚Ä¢ {grupo}: {horas}h ({dias:.0f} dias)")
    
    # Tentar janelas progressivamente maiores para alcan√ßar 90%+ de acur√°cia
    janelas_tentativas = [2, 6, 24, 72, 168]  # horas (2h, 6h, 1d, 3d, 7d)
    veiculos_encontrados = []
    
    for janela_atual in janelas_tentativas:
        print(f"üîÑ Tentativa com janela de {janela_atual}h...")
        
        inicio_local = agora_local - timedelta(hours=janela_atual)
        inicio_utc = inicio_local.astimezone(timezone.utc)
        
        params = {
            "startUpdatedAtTimestamp": inicio_utc.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z',
            "endUpdatedAtTimestamp": agora_utc.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z',
            "page": 1,
            "size": 1000,
            "sort": "updatedAt,desc"
        }
        
        try:
            param_string = urllib.parse.urlencode(params)
            full_url = f"{endpoint}?{param_string}"
            
            request = urllib.request.Request(full_url, headers=headers)
            
            with urllib.request.urlopen(request, timeout=60) as response:
                if response.status == 200:
                    data = json.loads(response.read().decode('utf-8'))
                    eventos = data.get('content', [])
                    
                    print(f"   üìä {len(eventos)} eventos retornados")
                    
                    # TESTE: Contar com ambos crit√©rios para compara√ß√£o
                    eventos_sem_saida_dateout = sum(1 for e in eventos 
                                          if e.get('fenceDescription', '') in POIS_FILTRADOS 
                                          and not e.get('dateOutFence', ''))
                    
                    eventos_status_1 = sum(1 for e in eventos 
                                          if e.get('fenceDescription', '') in POIS_FILTRADOS 
                                          and e.get('status', 0) == 1)
                    
                    print(f"   üîç dateOutFence vazio: {eventos_sem_saida_dateout} ve√≠culos")
                    print(f"   üìä status = 1: {eventos_status_1} ve√≠culos")
                    
                    # Usar status = 1 para o teste comparativo
                    eventos_sem_saida = eventos_status_1
                    
                    print(f"   üîç {eventos_sem_saida} ve√≠culos ainda dentro dos POIs")
                    
                    if eventos_sem_saida > 0:
                        print(f"   ‚úÖ Processando eventos da janela de {janela_atual}h...")
                        # Processar eventos desta janela
                        veiculos_encontrados = processar_eventos(eventos, janelas_grupo, agora_local)
                        
                        # Verificar se atingiu meta de acur√°cia (12+ ve√≠culos em Descarga Inocencia)
                        veiculos_descarga = [v for v in veiculos_encontrados if v['poi'] == 'Descarga Inocencia']
                        print(f"   üìä {len(veiculos_descarga)} ve√≠culos em 'Descarga Inocencia'")
                        
                        if len(veiculos_descarga) >= 12:
                            print(f"   üéØ Meta atingida (90%+)! Finalizando.")
                            break
                        else:
                            acuracia = len(veiculos_descarga)/15*100
                            print(f"   üìà Acur√°cia: {acuracia:.1f}% - tentando janela maior...")
                            # N√£o quebra o loop, continua para pr√≥xima janela
                    else:
                        print(f"   ‚ö†Ô∏è  Nenhum ve√≠culo ativo - tentando janela maior...")
                        
        except Exception as e:
            print(f"   ‚ùå Erro na tentativa {janela_atual}h: {e}")
            continue
    
    return veiculos_encontrados

def processar_eventos(eventos, janelas_grupo, agora_local):
    """Processa eventos aplicando filtros de janela temporal por grupo"""
    veiculos_ativos = []
    eventos_pois_filtrados = 0
    eventos_sem_data_saida = 0
    eventos_validos = 0
    
    # Processar cada evento
    for evento in eventos:
        poi = evento.get('fenceDescription', '')
        data_saida = evento.get('dateOutFence', '')
        status = evento.get('status', 0)  # TESTE: obter status primeiro
        
        # Debug contadores
        if poi in POIS_FILTRADOS:
            eventos_pois_filtrados += 1
            if status == 1:  # TESTE: mudou para status = 1
                eventos_sem_data_saida += 1
        
        # Filtrar apenas POIs monitorados e ve√≠culos ainda dentro (status = 1)
        if poi in POIS_FILTRADOS and status == 1:
            placa = evento.get('vehiclePlate', '')
            entrada = evento.get('dateInFence', '')
            
            if placa and entrada:
                # Converter entrada para timezone local
                dt_entrada = datetime.fromisoformat(entrada.replace('Z', '+00:00'))
                entrada_local = dt_entrada.astimezone(CAMPO_GRANDE_TZ)
                
                # Calcular tempo de perman√™ncia
                tempo_permanencia = (agora_local - entrada_local).total_seconds() / 3600
                
                filial = obter_filial_poi(poi)
                grupo = obter_grupo_poi(poi)
                
                # IGNORAR grupos sem SLA definido
                if grupo == "N√£o Mapeado":
                    continue
                
                # Aplicar janela temporal espec√≠fica do grupo
                janela_grupo = janelas_grupo.get(grupo, 24)  # default 24h
                if tempo_permanencia > janela_grupo:
                    continue
                
                eventos_validos += 1
                veiculo_info = {
                    'placa': placa,
                    'poi': poi,
                    'filial': filial,
                    'grupo': grupo,
                    'entrada': entrada_local,
                    'tempo_permanencia_horas': tempo_permanencia,
                    'evento_id': evento.get('pontoNotavelId')
                }
                veiculos_ativos.append(veiculo_info)
    
    # Debug: Mostrar contadores
    print(f"üîç Filtragem final:")
    print(f"   ‚Ä¢ Eventos em POIs monitorados: {eventos_pois_filtrados}")
    print(f"   ‚Ä¢ Eventos sem data de sa√≠da: {eventos_sem_data_saida}")
    print(f"   ‚Ä¢ Eventos dentro da janela temporal: {eventos_validos}")
    print(f"‚úÖ {len(veiculos_ativos)} ve√≠culos ativos encontrados")
    
    return veiculos_ativos

def analisar_desvios_sla(veiculos_ativos, timestamp_verificacao=None):
    """Analisa desvios de SLA por grupo"""
    if timestamp_verificacao is None:
        timestamp_verificacao = datetime.now(CAMPO_GRANDE_TZ)
    
    print(f"\nüìä AN√ÅLISE DE DESVIOS - {timestamp_verificacao.strftime('%d/%m/%Y %H:00:00')}")
    print("=" * 60)
    
    # Agrupar ve√≠culos por filial e grupo
    grupos_veiculo = defaultdict(list)
    
    for veiculo in veiculos_ativos:
        filial = veiculo['filial']
        grupo = veiculo['grupo']
        chave_grupo = f"{filial}_{grupo}"
        grupos_veiculo[chave_grupo].append(veiculo)
    
    desvios_detectados = []
    
    print("üìã STATUS POR GRUPO:")
    print("-" * 40)
    
    # Verificar cada grupo
    for chave_grupo, veiculos in grupos_veiculo.items():
        filial, grupo = chave_grupo.split('_', 1)
        qtd_veiculos = len(veiculos)
        
        # Obter limite SLA (apenas para grupos definidos)
        limite_sla = SLA_LIMITES.get(filial, {}).get(grupo)
        if limite_sla is None:
            # Grupo sem SLA definido - pular
            continue
        
        # Verificar se h√° desvio
        em_desvio = qtd_veiculos > limite_sla
        status_icon = "üö®" if em_desvio else "‚úÖ"
        
        print(f"{status_icon} {filial} - {grupo}: {qtd_veiculos}/{limite_sla} ve√≠culos")
        
        if em_desvio:
            desvio_info = {
                'filial': filial,
                'grupo': grupo,
                'qtd_veiculos': qtd_veiculos,
                'limite_sla': limite_sla,
                'veiculos': veiculos,
                'timestamp_verificacao': timestamp_verificacao
            }
            desvios_detectados.append(desvio_info)
            
            # Mostrar detalhes dos ve√≠culos em desvio
            print(f"   Ve√≠culos:")
            for v in veiculos[:5]:  # m√°ximo 5 para n√£o poluir
                tempo_str = f"{v['tempo_permanencia_horas']:.1f}h"
                print(f"     ‚Ä¢ {v['placa']} em {v['poi']} ({tempo_str})")
            if len(veiculos) > 5:
                print(f"     ‚Ä¢ ... e mais {len(veiculos) - 5} ve√≠culos")
    
    print(f"\nüéØ RESULTADO: {len(desvios_detectados)} grupo(s) em desvio de SLA")
    
    return desvios_detectados

def gerar_eventos_desvio(desvios_detectados):
    """Gera eventos de desvio no formato especificado"""
    eventos_gerados = []
    
    for desvio in desvios_detectados:
        timestamp = desvio['timestamp_verificacao']
        
        # Formato do evento: {FILIAL}_{GRUPO}_{NIVEL_ALERTA}_{DATA}_{HORA}
        # Por enquanto, sempre N1 (precisamos implementar l√≥gica de n√≠veis)
        evento_id = f"{desvio['filial']}_{desvio['grupo']}_N1_{timestamp.strftime('%d%m%Y_%H%M%S')}"
        
        # Gerar um evento para cada ve√≠culo no grupo em desvio
        for veiculo in desvio['veiculos']:
            evento = {
                'evento_id': evento_id,
                'placa': veiculo['placa'],
                'grupo': f"{desvio['filial']}_{desvio['grupo']}",
                'data_entrada': veiculo['entrada'].isoformat(),
                'tempo_permanencia': veiculo['tempo_permanencia_horas'],
                'alerta': 'Tratativa N1',
                'poi': veiculo['poi'],
                'timestamp_verificacao': timestamp.isoformat(),
                'qtd_veiculos_grupo': desvio['qtd_veiculos'],
                'limite_sla': desvio['limite_sla']
            }
            eventos_gerados.append(evento)
    
    print(f"\nüìù EVENTOS GERADOS: {len(eventos_gerados)}")
    if eventos_gerados:
        print("Exemplos:")
        for evento in eventos_gerados[:3]:
            print(f"  ‚Ä¢ {evento['evento_id']}: {evento['placa']} ({evento['tempo_permanencia']:.1f}h)")
    
    return eventos_gerados

def gerar_relatorio_excel(veiculos_ativos, desvios_detectados, timestamp_verificacao):
    """Gera relat√≥rio detalhado em CSV (compat√≠vel com Excel)"""
    timestamp_str = timestamp_verificacao.strftime('%Y%m%d_%H%M%S')
    
    # Arquivo 1: Relat√≥rio completo de ve√≠culos ativos
    arquivo_veiculos = f"relatorio_veiculos_ativos_{timestamp_str}.csv"
    
    with open(arquivo_veiculos, 'w', newline='', encoding='utf-8-sig') as f:
        writer = csv.writer(f, delimiter=';')
        
        # Cabe√ßalho
        writer.writerow([
            'Timestamp_Verificacao', 'Filial', 'Grupo', 'POI', 'Placa_Veiculo',
            'Data_Entrada', 'Tempo_Permanencia_Horas', 'SLA_Limite', 
            'Qtd_Grupo', 'Status_SLA', 'Em_Desvio'
        ])
        
        # Agrupar para an√°lise
        grupos_info = defaultdict(list)
        for veiculo in veiculos_ativos:
            chave = f"{veiculo['filial']}_{veiculo['grupo']}"
            grupos_info[chave].append(veiculo)
        
        # Dados dos ve√≠culos
        for veiculo in veiculos_ativos:
            filial = veiculo['filial']
            grupo = veiculo['grupo']
            chave_grupo = f"{filial}_{grupo}"
            
            # Obter informa√ß√µes do grupo
            limite_sla = SLA_LIMITES.get(filial, {}).get(grupo, 0)
            qtd_grupo = len(grupos_info[chave_grupo])
            em_desvio = qtd_grupo > limite_sla
            status_sla = "DESVIO" if em_desvio else "OK"
            
            writer.writerow([
                timestamp_verificacao.strftime('%d/%m/%Y %H:%M:%S'),
                filial,
                grupo,
                veiculo['poi'],
                veiculo['placa'],
                veiculo['entrada'].strftime('%d/%m/%Y %H:%M:%S'),
                f"{veiculo['tempo_permanencia_horas']:.2f}",
                limite_sla,
                qtd_grupo,
                status_sla,
                'SIM' if em_desvio else 'N√ÉO'
            ])
    
    # Arquivo 2: Resumo por grupo
    arquivo_resumo = f"resumo_grupos_sla_{timestamp_str}.csv"
    
    with open(arquivo_resumo, 'w', newline='', encoding='utf-8-sig') as f:
        writer = csv.writer(f, delimiter=';')
        
        writer.writerow([
            'Timestamp_Verificacao', 'Filial', 'Grupo', 'Qtd_Veiculos', 
            'SLA_Limite', 'Status', 'Percentual_Ocupacao', 'Desvio'
        ])
        
        # Processar todos os grupos definidos
        for filial, grupos_sla in SLA_LIMITES.items():
            for grupo, limite in grupos_sla.items():
                chave_grupo = f"{filial}_{grupo}"
                veiculos_grupo = grupos_info.get(chave_grupo, [])
                qtd = len(veiculos_grupo)
                percentual = (qtd / limite * 100) if limite > 0 else 0
                em_desvio = qtd > limite
                status = "üö® DESVIO" if em_desvio else "‚úÖ OK"
                
                writer.writerow([
                    timestamp_verificacao.strftime('%d/%m/%Y %H:%M:%S'),
                    filial,
                    grupo,
                    qtd,
                    limite,
                    status,
                    f"{percentual:.1f}%",
                    'SIM' if em_desvio else 'N√ÉO'
                ])
    
    # Arquivo 3: Eventos de desvio (se houver)
    if desvios_detectados:
        arquivo_eventos = f"eventos_desvio_{timestamp_str}.csv"
        
        with open(arquivo_eventos, 'w', newline='', encoding='utf-8-sig') as f:
            writer = csv.writer(f, delimiter=';')
            
            writer.writerow([
                'Evento_ID', 'Filial', 'Grupo', 'Placa_Veiculo', 'POI',
                'Data_Entrada', 'Tempo_Permanencia_Horas', 'Nivel_Alerta',
                'Qtd_Veiculos_Grupo', 'SLA_Limite', 'Timestamp_Verificacao'
            ])
            
            for desvio in desvios_detectados:
                for veiculo in desvio['veiculos']:
                    evento_id = f"{desvio['filial']}_{desvio['grupo']}_N1_{timestamp_verificacao.strftime('%d%m%Y_%H%M%S')}"
                    
                    writer.writerow([
                        evento_id,
                        desvio['filial'],
                        desvio['grupo'],
                        veiculo['placa'],
                        veiculo['poi'],
                        veiculo['entrada'].strftime('%d/%m/%Y %H:%M:%S'),
                        f"{veiculo['tempo_permanencia_horas']:.2f}",
                        'N1',  # Por enquanto sempre N1
                        desvio['qtd_veiculos'],
                        desvio['limite_sla'],
                        timestamp_verificacao.strftime('%d/%m/%Y %H:%M:%S')
                    ])
    
    print(f"\nüìä RELAT√ìRIOS GERADOS:")
    print(f"   ‚Ä¢ {arquivo_veiculos} - Detalhes de todos os ve√≠culos")
    print(f"   ‚Ä¢ {arquivo_resumo} - Resumo por grupo")
    if desvios_detectados:
        print(f"   ‚Ä¢ {arquivo_eventos} - Eventos de desvio")
    
    return arquivo_veiculos, arquivo_resumo

def main():
    """Fun√ß√£o principal do sistema de detec√ß√£o de desvios"""
    print("üöõ SISTEMA DE DETEC√á√ÉO DE DESVIOS - SENTINELA BD")
    print("=" * 60)
    
    # Obter timestamp para verifica√ß√£o (sempre hora fechada)
    agora = datetime.now(CAMPO_GRANDE_TZ)
    hora_verificacao = agora.replace(minute=0, second=0, microsecond=0)
    
    print(f"üïê Verifica√ß√£o: {hora_verificacao.strftime('%d/%m/%Y %H:%M:%S')} (Campo Grande/MS)")
    print(f"üìä POIs monitorados: {len(POIS_FILTRADOS)}")
    print(f"üéØ Grupos mapeados: {len(set(MAPEAMENTO_POI_GRUPO.values()))}")
    
    print(f"\nüìã GRUPOS COM SLA DEFINIDO:")
    for filial, grupos in SLA_LIMITES.items():
        for grupo, limite in grupos.items():
            print(f"   ‚Ä¢ {filial} - {grupo}: limite {limite} ve√≠culos")
    
    # 1. Buscar ve√≠culos ativos
    veiculos_ativos = buscar_veiculos_ativos()
    
    if not veiculos_ativos:
        print("‚ÑπÔ∏è Nenhum ve√≠culo ativo encontrado nos POIs monitorados")
        return
    
    # Mostrar exemplos dos ve√≠culos ativos para valida√ß√£o
    print(f"\nüìù EXEMPLOS DE VE√çCULOS ATIVOS (primeiros 10):")
    print("-" * 80)
    print("PLACA    | FILIAL | GRUPO        | POI                    | TEMPO")
    print("-" * 80)
    for i, veiculo in enumerate(veiculos_ativos[:10]):
        placa = veiculo['placa'][:8].ljust(8)
        filial = veiculo['filial'].ljust(6)
        grupo = veiculo['grupo'][:12].ljust(12)
        poi = veiculo['poi'][:22].ljust(22)
        tempo = f"{veiculo['tempo_permanencia_horas']:.1f}h"
        print(f"{placa} | {filial} | {grupo} | {poi} | {tempo}")
    
    if len(veiculos_ativos) > 10:
        print(f"... e mais {len(veiculos_ativos) - 10} ve√≠culos")
    
    # 2. Analisar desvios de SLA
    desvios = analisar_desvios_sla(veiculos_ativos, hora_verificacao)
    
    # 3. Gerar eventos se houver desvios
    if desvios:
        eventos = gerar_eventos_desvio(desvios)
        
        # TODO: Enviar eventos para BigQuery (TAREFA 5)
        print("\nüöÄ PR√ìXIMOS PASSOS:")
        print("- Implementar l√≥gica de n√≠veis N1-N4 com persist√™ncia")
        print("- Enviar eventos para BigQuery (sz-wsp-00009)")
        print("- Configurar execu√ß√£o hor√°ria no Cloud Run")
        
    else:
        print("\n‚úÖ Nenhum desvio detectado - SLA dentro do esperado")
    
    # 4. Gerar relat√≥rios Excel para valida√ß√£o
    gerar_relatorio_excel(veiculos_ativos, desvios, hora_verificacao)
    
    # 5. Retornar dados estruturados para BigQuery
    return {
        'veiculos_ativos': veiculos_ativos,
        'desvios': desvios,
        'timestamp_verificacao': hora_verificacao,
        'resumo_grupos': gerar_resumo_grupos(veiculos_ativos),
        'sla_limites': {f"{filial}_{grupo}": limite for filial, grupos in SLA_LIMITES.items() for grupo, limite in grupos.items()},
        'qtd_por_grupo': {f"{v['filial']}_{v['grupo']}": sum(1 for vv in veiculos_ativos if vv['filial'] == v['filial'] and vv['grupo'] == v['grupo']) for v in veiculos_ativos}
    }

def gerar_resumo_grupos(veiculos_ativos):
    """Gera resumo de ocupa√ß√£o por grupo para BigQuery"""
    from collections import defaultdict
    
    grupos_info = defaultdict(list)
    for veiculo in veiculos_ativos:
        chave = f"{veiculo['filial']}_{veiculo['grupo']}"
        grupos_info[chave].append(veiculo)
    
    resumo = []
    for filial, grupos_sla in SLA_LIMITES.items():
        for grupo, limite in grupos_sla.items():
            chave_grupo = f"{filial}_{grupo}"
            veiculos_grupo = grupos_info.get(chave_grupo, [])
            qtd = len(veiculos_grupo)
            percentual = (qtd / limite * 100) if limite > 0 else 0
            em_desvio = qtd > limite
            
            resumo.append({
                'filial': filial,
                'grupo': grupo,
                'qtd_veiculos': qtd,
                'sla_limite': limite,
                'percentual_ocupacao': percentual,
                'em_desvio': em_desvio
            })
    
    return resumo

if __name__ == "__main__":
    main()